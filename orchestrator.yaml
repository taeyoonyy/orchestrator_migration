data:
  accounts:
    persistent: true
  token:
    persistent: true
function:
  get_response_struct:
    logic:
      $action: "elixir"
      value: |
        %{
           "method" => nil,
           "res_body" => nil,
           "is_success" => true
         }
  TEST_SET_DUMMY_ACCOUNTS:
    logic:
      $action: "elixir"
      value: |
        accounts1 = [%{"id" => "admin", "authority" => "Admin", "password" => "1234", "comment" => "test accounts"}]
        accounts2 = [%{"id" => "yty", "authority" => "read", "password" => "1234", "comment" => "test accounts"}]
        accounts3 = [%{"id" => "kkk", "authority" => "read", "password" => "1234", "comment" => "test accounts"}]
        set("accounts", accounts1 ++ accounts2 ++ accounts3)
  respond:
    logic:
      $action: "elixir"
      value: |
        # ARGUMENTS MUST BE A MAP LIKE THIS
        # %{
        #   "method" => "POST"
        #   "res_body" => nil, (default nil)
        #   "is_success" => true (default true)
        # }
        
        Log.info(v)
        res_body = v["res_body"]
        parse_res_body = if(is_map(res_body), do: res_body |> ISON.encode() |> Poison.encode!(), else: res_body)
        status_code = case  {v["method"], v["is_success"]} do
          {"GET", true} -> 200
          {"POST", true} -> 201
          {"PUT", true} -> 201
          {"DELETE", true} -> 204
          {_ , false} -> 400
          _ -> 405
        end
        
        # RESPONSE
        response = %{
          "headers" => %{
            "Content-Type" => "application/json"
          },
          "status_code" => status_code
        }
        Log.info(inspect status_code)
        Log.info(inspect parse_res_body)
        
        if (parse_res_body), do: Map.put(response, "body", parse_res_body) , else: response
  set_token:
    logic:
      $action: "elixir"
      value: |
        if get("token") ==  nil, do: set("token", %{})
        set(["token", v["id"]], v["token"])
instance:
  web_server:
    data:
      port: 33346
    event:
      received:
        $action: "match"
        matches:
          - do:
              $action: "elixir"
              value: |
                accounts = (get("accounts") || []) |> Enum.map(fn x -> Map.delete(x, "password") end)
                resp = %{"status" => "success", "result" => accounts} |> Poison.encode!()
                function("respond", resp)
            model:
              $ref: "/api/accounts GET"
          - do:
              $action: "elixir"
              value: |
                # Log.info(v["body"])  %{"id" => "admin", "password" => "admin"}
                accounts = v["body"]
                result_list = get("accounts") |> Enum.filter(fn x -> x["id"] == accounts["id"] && x["password"] == accounts["password"] end)
                response_data = function("get_response_struct")
                response = if !(result_list |> Enum.empty?)  do
                  [result] = result_list
                  token = :rand.uniform(1000)
                  function("set_token", %{"id"=> result["id"], "token" => token})
                  resp_body = %{
                      authority: result["authority"], 
                      id: result["id"],
                      token: token
                  }
                  %{ response_data | "method" => v["method"], "res_body" => resp_body}
                else
                  %{ response_data | "res_body" => %{"message" => "invalid"}, "is_success" => false}
                end
                Log.info(response)
                function("respond", response)
            model:
              $ref: "/api/login POST"
          - do:
              $action: "elixir"
              value: |
                clear(["token", v["headers"]["authorization"]])
                response = %{function("get_response_struct") | "method" => v["method"]}
                function("respond", response)
            model:
              $ref: "/api/logout GET"
          - do:
              $action: "elixir"
              value: |
                accounts = get("accounts")
                id = v["body"]["id"]
                new_accounts = Enum.reject(accounts, &match?(%{"id" => ^id}, &1))
                
                clear(["token", v["headers"]["authorization"]])
                
                set("accounts", new_accounts)
                response = %{function("get_response_struct") | "method" => v["method"]}
                function("respond", response)
            model:
              $ref: "/api/accounts DELETE"
        none:
          $action: "http response"
          body:
            $action: "sequence"
            value:
              - $action: "match"
                $set: "dir"
                key:
                  - "path"
                matches:
                  - do: "/index.html"
                    model:
                      const: "/"
                  - do:
                      $action: "get"
                      key: "path"
                    model:
                      pattern: "^/(js|css|fonts|img|/favicon.ico)"
                      type: "string"
                none: "/index.html"
              - $action: "elixir"
                value: |
                  ui_location = (File.cwd!() |> String.split("EdgeHub/interactor") |> Enum.at(0)) <> "EdgeHub/orchestrator/dist" <> v["dir"]
                  File.read!(ui_location)
    use: "http server"
model:
  /api/accounts DELETE:
    $parser: "json"
    properties:
      method:
        const: "DELETE"
        type: "string"
      path:
        const: "/api/accounts"
        type: "string"
    type: "object"
  /api/accounts GET:
    $parser: "json"
    properties:
      method:
        const: "GET"
        type: "string"
      path:
        const: "/api/accounts"
        type: "string"
    type: "object"
  /api/login POST:
    $parser: "json"
    properties:
      path:
        const: "/api/login"
        type: "string"
    type: "object"
  /api/logout GET:
    $parser: "json"
    properties:
      path:
        const: "/api/logout"
        type: "string"
    type: "object"
service: {}
