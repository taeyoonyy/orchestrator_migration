data:
  accounts:
    persistent: true
  entities:
    persistent: true
  groups:
    persistent: true
  setting_information:
    default:
      engineer_information:
        engineer:
          email: ""
          mobile: ""
          name: ""
        inspector:
          email: ""
          mobile: ""
          name: ""
      license:
        expriation_date: "UNLIMITED"
        license_id: "ENTERPRISE"
      system:
        application_version: ""
        platform_version: ""
        system_name: "Orchestrator"
    persistent: true
  token:
    persistent: true
function:
  get_response_struct:
    logic:
      $action: "elixir"
      value: |
        %{
           "method" => nil,
           "res_body" => nil,
           "is_success" => true
         }
  get_url:
    logic:
      $action: "elixir"
      value: |
        case v do
          :INTERACTOR_CONNECTION_CHECK -> "/api/device/test"
          :INSIGHT_CONNECTION_CHECK ->  "/api/config/dashboard_test"
          :INTERACTOR_INFORMATION -> "/api/device/detail"
          _ -> "NO URL"
        end
  http_request:
    logic:
      $action: "elixir"
      value: |
        Log.info(v)
        method = if v[:body], do: "POST", else: "GET"
        req_data = %{
          "headers" => %{"Content-Type" => "application/json"},
          "url" => v[:url],
          "method" => method,
          "body" => v[:body] |> ISON.encode() |> Poison.encode!()
        }
        
        Log.info(inspect req_data)
        
        case Service.Http.request(req_data) do
          {:ok, res_data} ->
            Log.info(res_data)
            res_data |> Map.from_struct() |> Map.get(:body) |> Poison.decode!
          {:error, res_data} ->
            reason = res_data |> Map.from_struct() |> Map.get(:reason)
            Logger.info(reason |> inspect)
            reason
          _ -> false
        end
  respond:
    logic:
      $action: "elixir"
      value: |
        # ARGUMENTS MUST BE A MAP LIKE THIS
        # %{
        #   "method" => "POST"
        #   "res_body" => nil, (default nil)
        #   "is_success" => true (default true)
        # }
        
        Log.info(v)
        res_body = v["res_body"]
        parse_res_body = if(is_map(res_body), do: res_body |> ISON.encode() |> Poison.encode!(), else: res_body)
        status_code = case  {v["method"], v["is_success"]} do
          {"GET", true} -> 200
          {"POST", true} -> 201
          {"PUT", true} -> 201
          {"DELETE", true} -> 204
          {_ , false} -> 400
          _ -> 405
        end
        
        # RESPONSE
        response = %{
          "headers" => %{
            "Content-Type" => "application/json"
          },
          "status_code" => status_code
        }
        Log.info(inspect status_code)
        Log.info(inspect parse_res_body)
        
        if (parse_res_body), do: Map.put(response, "body", parse_res_body) , else: response
  return_entity_connection_info:
    logic:
      $action: "elixir"
      value: |
        {category, group, entity} = v
        result = get("entities") |> Enum.filter(fn x -> x["category"] == category && x["group"] == group && x["entity"] == entity end) |> Enum.at(0)
        {result["ip"], result["port"], result["password"]}
        
        # function("return_entity_connection_info", {"interactor", "ytyg", "ytye"})
  set_token:
    logic:
      $action: "elixir"
      value: |
        if get("token") ==  nil, do: set("token", %{})
        set(["token", v["id"]], v["token"])
instance:
  web_server:
    data:
      port: 33346
    event:
      received:
        $action: "match"
        matches:
          - do:
              $action: "elixir"
              value: |
                accounts = (get("accounts") || []) |> Enum.map(fn x -> Map.delete(x, "password") end)
                response = %{ function("get_response_struct") | "method" => v["method"], "res_body" => accounts}
                function("respond", response)
            model:
              $ref: "/api/accounts GET"
          - do:
              $action: "elixir"
              value: |
                # Log.info(v["body"])  %{"id" => "admin", "password" => "admin"}
                accounts = v["body"]
                result_list = get("accounts") |> Enum.filter(fn x -> x["id"] == accounts["id"] && x["password"] == accounts["password"] end)
                response_data = function("get_response_struct")
                response = if !(result_list |> Enum.empty?)  do
                  [result] = result_list
                  token = :rand.uniform(1000)
                  function("set_token", %{"id"=> result["id"], "token" => token})
                  resp_body = %{
                      authority: result["authority"], 
                      id: result["id"],
                      token: token
                  }
                  %{ response_data | "method" => v["method"], "res_body" => resp_body}
                else
                  %{ response_data | "res_body" => %{"message" => "invalid"}, "is_success" => false}
                end
                Log.info(response)
                function("respond", response)
            model:
              $ref: "/api/login POST"
          - do:
              $action: "elixir"
              value: |
                clear(["token", v["headers"]["authorization"]])
                response = %{function("get_response_struct") | "method" => v["method"]}
                function("respond", response)
            model:
              $ref: "/api/logout GET"
          - do:
              $action: "elixir"
              value: |
                accounts = get("accounts")
                id = v["body"]["id"]
                new_accounts = Enum.reject(accounts, &match?(%{"id" => ^id}, &1))
                
                clear(["token", v["headers"]["authorization"]])
                
                set("accounts", new_accounts)
                response = %{function("get_response_struct") | "method" => v["method"]}
                function("respond", response)
            model:
              $ref: "/api/accounts DELETE"
          - do:
              $action: "elixir"
              value: |
                accounts = get("accounts") || []
                
                new_account = %{
                  "id" => v["body"]["id"],
                  "password" => v["body"]["password"],
                  "authority" => v["body"]["authority"],
                  "comment" => v["body"]["comment"]
                }
                
                set("accounts", accounts ++ [new_account])
                response = %{function("get_response_struct") | "method" => v["method"]}
                function("respond", response)
            model:
              $ref: "/api/accounts POST"
          - do:
              $action: "elixir"
              value: |
                Log.info(v["path"]["segment"]["id"])
                
                id = v["path"]["segment"]["id"]
                accounts = get("accounts")
                [account] = accounts |> Enum.filter(fn x -> x["id"] === id end)
                new_account = %{ account | "comment" => v["body"]["comment"]}
                Log.info(inspect new_account)
                
                set("accounts",  Enum.reject(accounts, &match?(%{"id" => ^id}, &1)) ++ [new_account])
                response = %{function("get_response_struct") | "method" => v["method"]}
                function("respond", response)
            model:
              $ref: "/api/accounts/{id} PUT"
          - do:
              $action: "elixir"
              value: |
                setting = get("setting_information")
                response = %{ function("get_response_struct") | "method" => v["method"], "res_body" => setting}
                function("respond", response)
            model:
              $ref: "/api/setting GET"
          - do:
              $action: "elixir"
              value: |
                response = try do
                  engineer = v["body"]["engineer"]
                  inspector = v["body"]["inspector"]
                  set(["setting_information", "engineer_information", "engineer"], engineer)
                  set(["setting_information", "engineer_information", "inspector"], inspector)
                  %{function("get_response_struct") | "method" => v["method"]}
                rescue
                  _ -> %{function("get_response_struct") | "is_success" => false, "res_body" => "invalid input data"}
                end
                function("respond", response)
            model:
              $ref: "/api/setting/engineer-inspector-information POST"
          - do:
              $action: "elixir"
              value: |
                response = try do
                  system_name = v["body"]["system_name"]
                  set(["setting_information", "system", "system_name"], system_name)
                  %{function("get_response_struct") | "method" => v["method"]}
                rescue
                  _ -> %{function("get_response_struct") | "is_success" => false, "res_body" => "invalid input data"}
                end
                function("respond", response)
            model:
              $ref: "/api/setting/system-information POST"
          - do:
              $action: "elixir"
              value: |
                # ARGUMENTS
                target_path = if v["path"]["segment"]["target"] === "interactor", do: function("get_url", :INTERACTOR_CONNECTION_CHECK), else: function("get_url", :INSIGHT_CONNECTION_CHECK)
                port = if is_number(v["body"]["port"]), do: to_string(v["body"]["port"]), else: v["body"]["port"]
                url = "http://" <> v["body"]["ip"] <> ":" <> port <> target_path
                
                # REQUEST TO API SERVER
                result = function("http_request", %{"url": url, "body": %{"password" => v["body"]["password"]}})
                
                # RESPONSE
                response_data = function("get_response_struct") 
                response = if result["result"] === "success" do
                  %{ response_data | "method" => v["method"], "res_body" => %{"message" => "connection check success"}}
                else
                  %{ response_data | "res_body" => %{"message" => "connection check fail"}, "is_success" => false}
                end
                function("respond", response)
            model:
              $ref: "/api/connections/{target} POST"
          - do:
              $action: "elixir"
              value: |
                entities = get("entities") || []
                new_entity = %{
                  "category" => v["body"]["category"],
                  "group" => v["body"]["group"],
                  "entity" => v["body"]["entity"],
                  "ip" => v["body"]["ip"],
                  "port" => v["body"]["port"],
                  "password" => v["body"]["password"]
                }
                
                set("entities", entities ++ [new_entity])
                response = %{function("get_response_struct") | "method" => v["method"]}
                function("respond", response)
            model:
              $ref: "/api/entities POST"
          - do:
              $action: "elixir"
              value: |
                entities = (get("entities") || []) |> Enum.map(fn x -> Map.delete(x, "password") end)
                response = %{ function("get_response_struct") | "method" => v["method"], "res_body" => entities}
                function("respond", response)
            model:
              $ref: "/api/entities GET"
          - do:
              $action: "elixir"
              value: |
                # {
                # 		"category": "interactor",
                #     "target": "entity",
                #     "group": "group1",
                #     "entity": "entity1-1"
                # }
                
                
                entities = get("entities")
                category = v["body"]["category"]
                group = v["body"]["group"]
                entity = v["body"]["entity"]
                Log.info("YEQWE")
                Log.info(entity)
                
                new_entities = if entity do
                  Enum.reject(entities, &match?(%{"category" => ^category, "group" => ^group, "entity" => ^entity}, &1))
                else
                  Enum.reject(entities, &match?(%{"category" => ^category, "group" => ^group}, &1))
                  Log.info("HERE?")
                  set("groups", Enum.reject(get("groups"), &match?(%{"category" => ^category, "group" => ^group}, &1)))
                end
                Log.info(new_entities)
                set("entities", new_entities)
                response = %{function("get_response_struct") | "method" => v["method"]}
                function("respond", response)
            model:
              $ref: "/api/entities DELETE"
          - do:
              $action: "elixir"
              value: |
                category = v["parameters"]["category"]
                group = v["parameters"]["group"]
                
                group_info = %{
                  "category" => category,
                  "group" => group,
                  "group_information" => v["body"]
                }
                
                groups = get("groups") || []
                
                set("groups",  Enum.reject(groups, &match?(%{"category" => ^category, "group" => ^group}, &1)) ++ [group_info])
                response = %{function("get_response_struct") | "method" => v["method"]}
                function("respond", response)
            model:
              $ref: "/api/groups POST"
          - do:
              $action: "elixir"
              value: |
                category = v["parameters"]["category"]
                group = v["parameters"]["group"]
                groups = get("groups") || []
                res_body = groups |> Enum.filter(fn x -> x["category"] == category && x["group"] == group end) |> Enum.at(0)
                res_body = if res_body, do: res_body, else: nil
                response = %{function("get_response_struct") | "method" => v["method"], "res_body" => res_body}
                function("respond", response)
            model:
              $ref: "/api/groups GET"
          - do:
              $action: "elixir"
              value: |
                # PREPARE DATA FOR HTTP REQUEST
                category = "interactor"
                group = v["parameters"]["group"]
                entity = v["parameters"]["entity"]
                {ip, port, password} = function("return_entity_connection_info", {category, group, entity})
                path = function("get_url", :INTERACTOR_INFORMATION)
                url = "http://" <> ip <> ":" <> port <> path
                
                # REQUEST TO API SERVER
                result = function("http_request", %{"url": url, "body": %{"password" => password}})
                
                # RESPONSE
                response_data = function("get_response_struct") 
                response = if result["result"] === "success" do
                  %{ response_data | "method" => v["method"], "res_body" => result["data"]}
                else
                  %{ response_data | "is_success" => false}
                end
                function("respond", response)

            model:
              $ref: "/api/interactor/info GET"
        none:
          $action: "http response"
          body:
            $action: "sequence"
            value:
              - $action: "match"
                $set: "dir"
                key:
                  - "path"
                matches:
                  - do: "/index.html"
                    model:
                      const: "/"
                  - do:
                      $action: "get"
                      key: "path"
                    model:
                      pattern: "^/(js|css|fonts|img|/favicon.ico)"
                      type: "string"
                none: "/index.html"
              - $action: "elixir"
                value: |
                  ui_location = (File.cwd!() |> String.split("EdgeHub/interactor") |> Enum.at(0)) <> "EdgeHub/orchestrator/dist" <> v["dir"]
                  File.read!(ui_location)
    use: "http server"
model:
  /api/accounts DELETE:
    $parser: "json"
    properties:
      method:
        const: "DELETE"
        type: "string"
      path:
        const: "/api/accounts"
        type: "string"
    type: "object"
  /api/accounts GET:
    $parser: "json"
    properties:
      method:
        const: "GET"
        type: "string"
      path:
        const: "/api/accounts"
        type: "string"
    type: "object"
  /api/accounts POST:
    $parser: "json"
    properties:
      method:
        const: "POST"
        type: "string"
      path:
        const: "/api/accounts"
        type: "string"
    type: "object"
  /api/accounts/{id} PUT:
    $parser: "json"
    properties:
      method:
        const: "PUT"
        type: "string"
      path:
        $parser: "path"
        pattern: "/api/accounts/{id}"
    type: "object"
  /api/connections/{target} POST:
    $parser: "json"
    properties:
      method:
        const: "POST"
        type: "string"
      path:
        $parser: "path"
        pattern: "/api/connections/{target}"
    type: "object"
  /api/entities DELETE:
    $parser: "json"
    properties:
      method:
        const: "DELETE"
        type: "string"
      path:
        const: "/api/entities"
        type: "string"
    type: "object"
  /api/entities GET:
    $parser: "json"
    properties:
      method:
        const: "GET"
        type: "string"
      path:
        const: "/api/entities"
        type: "string"
    type: "object"
  /api/entities POST:
    $parser: "json"
    properties:
      method:
        const: "POST"
        type: "string"
      path:
        const: "/api/entities"
        type: "string"
    type: "object"
  /api/groups GET:
    $parser: "json"
    properties:
      method:
        const: "GET"
        type: "string"
      path:
        const: "/api/groups"
        type: "string"
    type: "object"
  /api/groups POST:
    $parser: "json"
    properties:
      method:
        const: "POST"
        type: "string"
      path:
        const: "/api/groups"
        type: "string"
    type: "object"
  /api/interactor/info GET:
    $parser: "json"
    properties:
      method:
        const: "GET"
        type: "string"
      path:
        const: "/api/interactor/info"
        type: "string"
    type: "object"
  /api/login POST:
    $parser: "json"
    properties:
      method:
        const: "POST"
        type: "string"
      path:
        const: "/api/login"
        type: "string"
    type: "object"
  /api/logout GET:
    $parser: "json"
    properties:
      method:
        const: "GET"
        type: "string"
      path:
        const: "/api/logout"
        type: "string"
    type: "object"
  /api/setting GET:
    $parser: "json"
    properties:
      method:
        const: "GET"
        type: "string"
      path:
        const: "/api/setting"
        type: "string"
    type: "object"
  /api/setting/engineer-inspector-information POST:
    $parser: "json"
    properties:
      method:
        const: "POST"
        type: "string"
      path:
        const: "/api/setting/engineer-inspector-information"
        type: "string"
    type: "object"
  /api/setting/system-information POST:
    $parser: "json"
    properties:
      method:
        const: "POST"
        type: "string"
      path:
        const: "/api/setting/system-information"
        type: "string"
    type: "object"
service: {}
